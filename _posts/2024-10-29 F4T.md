---
title: "F4T"
categories:
  - blog
tags:
  - essay
---

# æ¯•è®¾

2024å¹´åˆè¦è¿‡å»ï¼Œçœ‹çœ‹ç ´ç ´çƒ‚çƒ‚çš„åšå®¢ï¼Œå¥½åƒæ²¡å‘å‡ ç¯‡ï¼ŒåŠ ä¸Šè¿™ç¯‡ï¼Œä¸€å…±2024å¹´æ‰æ‹‰äº†ä¸‰ç¯‡ï¼Œç¡®å®æœ‰ç‚¹ä¸‰åˆ†é’Ÿçƒ­åº¦ã€‚

æ˜¯å¤§å››çš„å¼€å§‹ï¼Œå¤§å­¦å°±è¦ç»“æŸäº†ï¼Œä»å‚åŠ å¤§åˆ›å¼€å§‹ï¼Œä»å®ä¹ å¼€å§‹ï¼Œâ€œæ‰“ç®—åšä¸€ä¸ªä»€ä¹ˆæ ·çš„æ¯•è®¾â€è¿™ä¸ªé—®é¢˜ï¼Œå°±ä¸€ç›´å¾˜å¾Šåœ¨æˆ‘çš„è„‘å­é‡Œã€‚

è¿™ä¸ªé—®é¢˜å¯èƒ½å¾ˆé•¿ï¼Œä¸€æ™šä¸Šè‚¯å®šå†™ä¸å®Œä¸€ç¯‡ï¼Œç¼ç¼è¡¥è¡¥ï¼Œèƒ½å†™å¤šå°‘ï¼Œç®—å¤šå°‘å¥½äº†ã€‚

##  1. F4T ï¼Ÿ

è¿™ä¸ªè¯¾é¢˜å…¶å®æ˜¯ä¸€ç›´æƒ³åšçš„ï¼Œä½†æ˜¯ä¸€ç›´æ²¡æœ‰æœºä¼šï¼Œè€Œä¸”ä¹Ÿæ„Ÿè§‰è‡ªå·±å®Œä¸æˆğŸ¤£ã€‚

å•¥æ˜¯F4Tï¼Ÿ

â€œA Fast and Flexible FPGA-based Full-stack
TCP Acceleration Frameworkâ€ä¸€ä¸ªå¿«é€Ÿçµæ´»çš„åŸºäºFPGAçš„å…¨æ ˆTCPåŠ é€Ÿæ¡†æ¶ï¼Œå‚è€ƒåŒåè®ºæ–‡ã€‚

ä¸ºä»€ä¹ˆä¼šæœ‰åšè¿™ä¹ˆä¸€ä¸ªæ‹—å£çš„è¯¾é¢˜çš„æƒ³æ³•ï¼Ÿ

åœ¨Calixå®ä¹ çš„æ—¶å€™ï¼Œæ¥è§¦çš„å¤§å¤šæ˜¯äºŒå±‚ä¸‰å±‚è®¾å¤‡ï¼Œå…¶ä¸­æŠ“å–æ•°æ®åŒ…ä¸€æ®µï¼Œèƒ½çœ‹åˆ°æ•°æ®åŒ…è§£æçš„å®Œæ•´æµç¨‹ï¼Œä»ä¸€ä¸ªå…‰çº¤é“¾è·¯ä¸Šçš„OMCI/PLOAMæ•°æ®åŒ…ï¼Œåˆ°MAC/IPæ•°æ®åŒ…ï¼Œåœ¨äº¤ç»™å†…æ ¸å»åšå››å±‚è§£æå’Œæ‹†åˆ†ï¼ŒICMP/UDP/TCPåˆ†åˆ«äº¤ç»™å¯¹åº”çš„è§£æå»åšï¼Œé’ˆå¯¹TCPæ¥è¯´ï¼Œæ¨¡ç³Šçš„è®°å¾—å†…æ ¸é‡Œå¤´æœ‰sk_buffè¿™ä¹ˆä¸ªæ•°æ®ç»“æ„ï¼Œä»è¿™ä¸ªbuffä¸­ä¸åœpollå‡ºæ¥æ¯ä¸ªæ•°æ®åŒ…çš„åŒ…å¤´ï¼Œå†å¯¹åŒ…å¤´åšå¤„ç†ã€‚

Linuxå†…æ ¸ä¸­ï¼Œå…³äºsk_buffæœ‰è¿™ä¹ˆä¸ªæ³¨é‡Šï¼š

```c
/**
 * DOC: Basic sk_buff geometry
 *
 * struct sk_buff itself is a metadata structure and does not hold any packet
 * data. All the data is held in associated buffers.
 *
 * &sk_buff.head points to the main "head" buffer. The head buffer is divided
 * into two parts:
 *
 *  - data buffer, containing headers and sometimes payload;
 *    this is the part of the skb operated on by the common helpers
 *    such as skb_put() or skb_pull();
 *  - shared info (struct skb_shared_info) which holds an array of pointers
 *    to read-only data in the (page, offset, length) format.
 *
 * Optionally &skb_shared_info.frag_list may point to another skb.
 *
 * Basic diagram may look like this::
 *
 *                                  ---------------
 *                                 | sk_buff       |
 *                                  ---------------
 *     ,---------------------------  + head
 *    /          ,-----------------  + data
 *   /          /      ,-----------  + tail
 *  |          |      |            , + end
 *  |          |      |           |
 *  v          v      v           v
 *   -----------------------------------------------
 *  | headroom | data |  tailroom | skb_shared_info |
 *   -----------------------------------------------
 *                                 + [page frag]
 *                                 + [page frag]
 *                                 + [page frag]
 *                                 + [page frag]       ---------
 *                                 + frag_list    --> | sk_buff |
 *                                                     ---------
 *
 */
```

Ummä»æ³¨é‡Šä¸Šçœ‹è¿™ä¸ªå…¶å®æ˜¯ä¸ªå…ƒæ•°æ®ç»“æ„ï¼Œç„¶åä»æ³¨é‡Šä¸Šçœ‹ï¼Œè¿™ä¸ªdataæŒ‡é’ˆå¹¶ä¸ä¸€å®šåŒ…å«payloadï¼Œä½†æ˜¯ä¸€å®šåŒ…å«äºŒå±‚å¸§å¤´ï¼Œä¸åŒ…å«payloadçš„è¯ï¼Œpayloadå°±ä¼šè¢«æ”¾åœ¨ `skb_shared_info` æŒ‡é’ˆæŒ‡å‘çš„åªè¯»ç©ºé—´å†…ã€‚

### 1.1 ç›®å‰TCPä¸»è¦æ—¶å»¶

å‚è€ƒè®ºæ–‡ï¼ŒTCPçš„æ—¶å»¶å¤§æ¦‚åœ¨ä»¥ä¸‹å‡ ä¸ªåœ°æ–¹ï¼š

- æœ‰çŠ¶æ€æ“ä½œå¤„ç†æ•ˆç‡ä½ä¸‹ï¼ˆè¿™è¾¹çš„æœ‰çŠ¶æ€ä¸çŸ¥é“æ˜¯ä¸æ˜¯æˆ‘ç†è§£çš„åœ¨å»ºç«‹è¿æ¥æ—¶å¤„ç†sk_buffçš„æ•°æ®å¤ªæ…¢ï¼‰
- ç¼ºä¹åˆ©ç”¨å¤šä¸ªå†…å­˜æ¨¡å—è¿›è¡ŒtcpçŠ¶æ€ç®¡ç†


## Ref

- sk_buff
```c
struct sk_buff {
	union {
		struct {
			/* These two members must be first to match sk_buff_head. */
			struct sk_buff		*next;
			struct sk_buff		*prev;

			union {
				struct net_device	*dev;
				/* Some protocols might use this space to store information,
				 * while device pointer would be NULL.
				 * UDP receive path is one user.
				 */
				unsigned long		dev_scratch;
			};
		};
		struct rb_node		rbnode; /* used in netem, ip4 defrag, and tcp stack */
		struct list_head	list;
		struct llist_node	ll_node;
	};

	struct sock		*sk;

	union {
		ktime_t		tstamp;
		u64		skb_mstamp_ns; /* earliest departure time */
	};
	/*
	 * This is the control buffer. It is free to use for every
	 * layer. Please put your private variables there. If you
	 * want to keep them across layers you have to do a skb_clone()
	 * first. This is owned by whoever has the skb queued ATM.
	 */
	char			cb[48] __aligned(8);

	union {
		struct {
			unsigned long	_skb_refdst;
			void		(*destructor)(struct sk_buff *skb);
		};
		struct list_head	tcp_tsorted_anchor;
#ifdef CONFIG_NET_SOCK_MSG
		unsigned long		_sk_redir;
#endif
	};

#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
	unsigned long		 _nfct;
#endif
	unsigned int		len,
				data_len;
	__u16			mac_len,
				hdr_len;

	/* Following fields are _not_ copied in __copy_skb_header()
	 * Note that queue_mapping is here mostly to fill a hole.
	 */
	__u16			queue_mapping;

/* if you move cloned around you also must adapt those constants */
#ifdef __BIG_ENDIAN_BITFIELD
#define CLONED_MASK	(1 << 7)
#else
#define CLONED_MASK	1
#endif
#define CLONED_OFFSET		offsetof(struct sk_buff, __cloned_offset)

	/* private: */
	__u8			__cloned_offset[0];
	/* public: */
	__u8			cloned:1,
				nohdr:1,
				fclone:2,
				peeked:1,
				head_frag:1,
				pfmemalloc:1,
				pp_recycle:1; /* page_pool recycle indicator */
#ifdef CONFIG_SKB_EXTENSIONS
	__u8			active_extensions;
#endif

	/* Fields enclosed in headers group are copied
	 * using a single memcpy() in __copy_skb_header()
	 */
	struct_group(headers,

	/* private: */
	__u8			__pkt_type_offset[0];
	/* public: */
	__u8			pkt_type:3; /* see PKT_TYPE_MAX */
	__u8			ignore_df:1;
	__u8			dst_pending_confirm:1;
	__u8			ip_summed:2;
	__u8			ooo_okay:1;

	/* private: */
	__u8			__mono_tc_offset[0];
	/* public: */
	__u8			tstamp_type:2;	/* See skb_tstamp_type */
#ifdef CONFIG_NET_XGRESS
	__u8			tc_at_ingress:1;	/* See TC_AT_INGRESS_MASK */
	__u8			tc_skip_classify:1;
#endif
	__u8			remcsum_offload:1;
	__u8			csum_complete_sw:1;
	__u8			csum_level:2;
	__u8			inner_protocol_type:1;

	__u8			l4_hash:1;
	__u8			sw_hash:1;
#ifdef CONFIG_WIRELESS
	__u8			wifi_acked_valid:1;
	__u8			wifi_acked:1;
#endif
	__u8			no_fcs:1;
	/* Indicates the inner headers are valid in the skbuff. */
	__u8			encapsulation:1;
	__u8			encap_hdr_csum:1;
	__u8			csum_valid:1;
#ifdef CONFIG_IPV6_NDISC_NODETYPE
	__u8			ndisc_nodetype:2;
#endif

#if IS_ENABLED(CONFIG_IP_VS)
	__u8			ipvs_property:1;
#endif
#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE) || IS_ENABLED(CONFIG_NF_TABLES)
	__u8			nf_trace:1;
#endif
#ifdef CONFIG_NET_SWITCHDEV
	__u8			offload_fwd_mark:1;
	__u8			offload_l3_fwd_mark:1;
#endif
	__u8			redirected:1;
#ifdef CONFIG_NET_REDIRECT
	__u8			from_ingress:1;
#endif
#ifdef CONFIG_NETFILTER_SKIP_EGRESS
	__u8			nf_skip_egress:1;
#endif
#ifdef CONFIG_SKB_DECRYPTED
	__u8			decrypted:1;
#endif
	__u8			slow_gro:1;
#if IS_ENABLED(CONFIG_IP_SCTP)
	__u8			csum_not_inet:1;
#endif
	__u8			unreadable:1;
#if defined(CONFIG_NET_SCHED) || defined(CONFIG_NET_XGRESS)
	__u16			tc_index;	/* traffic control index */
#endif

	u16			alloc_cpu;

	union {
		__wsum		csum;
		struct {
			__u16	csum_start;
			__u16	csum_offset;
		};
	};
	__u32			priority;
	int			skb_iif;
	__u32			hash;
	union {
		u32		vlan_all;
		struct {
			__be16	vlan_proto;
			__u16	vlan_tci;
		};
	};
#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)
	union {
		unsigned int	napi_id;
		unsigned int	sender_cpu;
	};
#endif
#ifdef CONFIG_NETWORK_SECMARK
	__u32		secmark;
#endif

	union {
		__u32		mark;
		__u32		reserved_tailroom;
	};

	union {
		__be16		inner_protocol;
		__u8		inner_ipproto;
	};

	__u16			inner_transport_header;
	__u16			inner_network_header;
	__u16			inner_mac_header;

	__be16			protocol;
	__u16			transport_header;
	__u16			network_header;
	__u16			mac_header;

#ifdef CONFIG_KCOV
	u64			kcov_handle;
#endif

	); /* end headers group */

	/* These elements must be at the end, see alloc_skb() for details.  */
	sk_buff_data_t		tail;
	sk_buff_data_t		end;
	unsigned char		*head,
				*data;
	unsigned int		truesize;
	refcount_t		users;

#ifdef CONFIG_SKB_EXTENSIONS
	/* only usable after checking ->active_extensions != 0 */
	struct skb_ext		*extensions;
#endif
};
```